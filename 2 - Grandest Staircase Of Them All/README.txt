I was able to pretty easily recognize this problem as being 'write a cardinality function for strict partitions (but excluding the strict partition with one part). Or OEIS sequence A000009 ( https://oeis.org/A000009 ), but minus 1. I've done a lot of work with similar types of things (in particular, symmetric plane partitions). I wasted a lot of time on this because I originally wanted to write an iterator to generate all strict partitions, and got bogged down in remembering exactly how to make yield statements do what I wanted. But total enumeration is too slow of a cardinality method for the cases they wanted you to be able to handle, so I had to switch to a recurrence relation

The rough idea is that f(boxes_left,largest_part) returns the number of strict partitions of 'boxes_left', where the first entry must be less than 'largest_part'. We recursively run this for all possible ways of adding a next box, initialized with having n boxes left and largest part must be less than n (this will exclude the singleton partition). However, if we do this as a straight recursion, we are effectively still just iterating over all possible strict partitions, we just aren't constructing the actual partition along the way.

The thing that's necessary to speed this up is an auxilliary list that keeps track of values f(boxes_left,largest_part) we've already computed instead of repeating the recursive procedure each time that function is called. In my submitted solution, I did this somewhat clunkily with a global list that I made large enough for the bounds given in the problem, but keeping a running dictionary is much more efficient, and is done in the solution presented here.