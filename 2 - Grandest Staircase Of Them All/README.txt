I was able to pretty easily recognize this problem as being 'write a cardinality function for strict partitions (but excluding the strict partition with one part). Or OEIS sequence A000009 ( https://oeis.org/A000009 ), but minus 1. I've done a lot of work with similar types of things (in particular, symmetric plane partitions). I wasted a lot of time on this because I originally wanted to write an iterator to generate all strict partitions, and got bogged down in remembering exactly how to make yield statements do what I wanted. But total enumeration is too slow of a cardinality method for the cases they wanted you to be able to handle, so I had to switch to a recurrence relation

The rough idea is that f(boxes_left,largest_part) returns the number of strict partitions of 'boxes_left', where the first entry must be less than 'largest_part'. We recursively run this for all possible ways of adding a next box, initialized with having n boxes left and largest part must be less than n (this will exclude the singleton partition). However, if we do this as a straight recursion, we are effectively still just iterating over all possible strict partitions, we just aren't constructing the actual partition along the way.

The thing that's necessary to speed this up is an auxilliary list that keeps track of values f(boxes_left,largest_part) we've already computed instead of repeating the recursive procedure each time that function is called. In my submitted solution, I did this somewhat clunkily with a global list that I made large enough for the bounds given in the problem, but keeping a running dictionary is much more efficient, and is done in the solution presented here.

Edit (July 2020): Upon further review, this is 100% supposed to be a dynamic programming problem, and it seems I managed to come up with the top-down/memoized version. I may revisit this and rewrite a bottom-up/dynamic programming approach instead (start with boundary conditions f(0,j)=1 and then use recurrence relation to systematically compute the entire table of f(i,j) values). Both methods have same asymptotics, bottom-up tends to have a better constant from less overhead in recursion and other efficiencies. Top-down can be beneficial when there are a significant number of "sub-problems" that never arise when you recurse down, but would be needlessly solved when you go from the bottom up, though that would not be the case for this problem.
