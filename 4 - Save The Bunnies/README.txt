This was pretty obviously supposed to be some kind of graph theory optimization problem, though probably not something that just required a direct implementation of a standard algorithm. In retrospect, some search terms were bad ideas (Hamiltonian paths are about hitting every vertex in a graph, but edge weights don't really come into play). But including the caveat about negative weights (and potential infinite cycles) lead relatively quickly to the Bellman-Ford algorithm.

The Bellman-Ford algorithm takes a weighted and directed graph, and constructs the shortest path from a given vertex to all other vertices (while also determining if the graph has a negative cycle, which would allow this shortest path to be infinite). We can't just directly apply this with our starting position and the bulkhead, because ultimately the goal is to maximize how many other vertices we hit along the way while still keeping total time under the specified limit.

So the first step is to apply Bellman-Ford to all possible starting vertices and obtain a matrix giving the length of the shortest path between two vertices. Maybe a slightly non-intuitive step if you're used to expecting digraphs to be modeling some kind of distance/metric that naturally satisfies the triangle inequality.

Now to combine this information to see how many bunnies can be saved. We choose a subset of bunnies we think we can save, starting with as many bunnies as once, and then trying out smaller subsets in the prescribed order (it has a fancy name similar to, but not exactly the same as, rev lex). Note that distances aren't necessarily symmetric, so not only do we need to try all subsets of bunnies, but for each subset we also need to try all permutations of those bunnies (ie, testing SP -> bunny A -> bunny B -> bulkhead and SP -> bunny B -> bunny A -> bulkhead) separately.