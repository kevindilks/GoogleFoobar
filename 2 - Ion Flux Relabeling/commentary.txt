The solution I submitted (and at least initially have presented here) is not ideal, in the sense that I took advantage of the specific structure of this (complete) binary tree, and really should have done something that more generally returns the predecessor of a node in a binary tree.

Overall structure is that I write a loop that returns the predecessor of node labeled 'n' in the tree of depth 'p', and then run that loop for every element of the list. My guess would be a different/better solution would just search the tree through once and make a predecessor or successor dictionary that you then applied to values in the list.

The idea we exploit is that for one of these labeled trees of depth 'p', the left subtree is precisely one of these labeled trees of depth 'p-1', and the right sub-tree is also one of these labeled trees of depth 'p-1', but with 2**(p-1)-1 added to every label.

We initialize by checking that if we're 2**p-1, then we're at the top of the tree, and have no predecessor, so we should return -1. Otherwise, each step takes us down one level in the tree. We keep track of the node we just went down from, and the node we just went down to. If the node we just went down to is the desired node, then the node we just came down from is the desired predecessor. Otherwise, we repeat. In retrospect, I could probably make this just construct the whole chain of predecessors leading down to the desired node 'n'.

Some specific structure we take advantage of is the fact that if we follow a left child from the top node of a labeled tree of depth 'n' to the left subtree that is precisely a labeled tree of depth 'p-1', then label of the top node in the tree we're working with goes down by 2**(p-1). If we follow a right child into the right subtree which is a labelled tree of depth 'p-1' with all labels incremented by 2**(p-1), then the label of the top node decreases by 1. We keep a 'running_total' to account for all the times we've followed a right child and have subtracted off 2**(k-1) to be working in a copy that is exactly a labelled tree of depth 'k'.

Edit (July 2020): After getting a little more background in heap-sort/binary search trees/etc. , I've realized I was previously a bit too pessimistic in my solution. It's definite not a hack for your binary trees to have some nice structure in the node labellings so you can easily do your parent/left child/right child operation in terms of simple bit operations (main example coming to mind in the one with heap-sort and having parent(i) = floor(i/2), left_child(i) = 2i , right_child(i) = 2i+1). I also hadn't put much thought into the relative sizes of the number of things to be searched for and the search space. You would definitely want to do a search that takes at most h steps (1<h<30) once for each of the 1<|q|<10000 elements instead of doing one complete search of a tree with 2**h-1 elements (over 1 trillion if h=30). Almost like that's the reason binary search trees are useful :) .
